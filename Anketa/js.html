<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  
  <p>Вот значения, которые при приведению к логическому типу дают false: 0, -0, +0, null, false, NaN, undefined, ''
    (пустая строка).

    Все остальные значения в JavaScript (в других языках бывает не так) дают true.

    Вот значения, приводящиеся к true, но могущие вызвать у вас сомнения: -1, Infinity, -Infinity.

    Следующие значения являются строками, так как взяты в кавычки, и также приводятся к true: '0', 'false', 'NaN',
    'null', 'undefined'.</p>


<p> </p>

    let num = 0;
num = num + 1; // прибавляем к переменной num число 1
alert(num); // выведет 1

let num = 0;
num += 1; // прибавляем к переменной num число 1
alert(num); // выведет 1

В случае alert(a++) переменная сначала выведется, а потом увеличится на единицу, а в случае alert(++a) переменная
сначала увеличится на единицу, а потом выведется.

В следующем примере первый alert выведет 0, так как вначале сработает вывод на экран, а уже затем переменная увеличится:

let num = 0;
alert(num++); // выведет
0, тк переменная увеличится только после алерта
alert(num); // выведет 1 - переменная поменялась

let num1 = 3;
let num2 = num1++;
alert(num1);
alert(num2);

let obj = {key1: 'a', key2: 'b', key3: 'c'};
console.log(obj.key1); // альтернативный способ
Как вы видите, в данном случае мы пишем после переменной с объектом мы пишем точку и имя ключа без кавычек.

Данный альтернативный способ имеет ограничение: так допустимо обращаться только к тем ключам, которых при создании
объекта не обязательно брать в кавычки.

console.log(typeof []); // тоже выведет 'object'
Дело в том, что на самом деле в JavaScript нет отдельного типа данных для массивов - каждый массив представляет собой
частный случай объекта.

Объекты (в том числе и массивы, как вы уже знаете) считаются сложными типами данных. Строки, числа, логические значения
считаются простыми, или примитивными типами данных.

Их часто так и называют - примитивы, подразумевая все то, что не является объектом.

В JavaScript шесть примитивных типов данных: string, number, boolean, null, undefined, symbol (новое в ES6).

Логическое ИЛИ требует выполнения хотя бы одного условия.
Логическое И позволяет задать одновременность условий. В следующем примере, если переменная num больше нуля и
одновременно меньше 10, только тогда выведется 'верно':
Операция && имеет приоритет над ||.

В предыдущем примере я использовал для сравнения оператор ===. В этом случае наша переменная сравнивалась на равенство
true как по значению, так и по типу.

В нашей задаче можно использовать и оператор ==. Если в переменной test всегда будет одно из значений true или false, то
ничего и не изменится:


let test = true;

if (test) { // эквивалентно if (test == true)
alert('верно');
} else {
alert('неверно');
}

Учтите, что в сокращенных операциях сравнение идет по ==, а не по ===.


if (true) {
let result = '!';
}

console.log(result);
Как вы видите, в переменную result должно записаться значение '!'. Однако, если запустить этот код, то в консоль
выведется ошибка!

Дело в том, что переменные, объявленные внутри фигурных скобок, видны только внутри этих скобок, и не видны снаружи.
</body>
</html>